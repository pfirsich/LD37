<!DOCTYPE html>
<html lang="en">
    <head>
        <title>LD37 GAME</title>
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
        <style>
            html, body {
                width: 100%;
                height: 100%;
            }

            body {
                background-color: #ffffff;
                margin: 0;
                overflow: hidden;
                font-family: arial;
            }

            #blocker {
                position: absolute;
                width: 100%;
                height: 100%;
                background-color: rgba(0,0,0,0.5);
            }

            #instructions {

                width: 100%;
                height: 100%;

                display: -webkit-box;
                display: -moz-box;
                display: box;

                -webkit-box-orient: horizontal;
                -moz-box-orient: horizontal;
                box-orient: horizontal;

                -webkit-box-pack: center;
                -moz-box-pack: center;
                box-pack: center;

                -webkit-box-align: center;
                -moz-box-align: center;
                box-align: center;

                color: #ffffff;
                text-align: center;

                cursor: pointer;
                font-size: 25px;

            }

            #info {
                margin: 0px;
                position:absolute;
                font-size: 45px;
                font-family: "Inconsolata", monospace;
                color: #000000;
                font-weight: bold;
                width: 100%;
            }

        </style>
    </head>
    <body>
        <link href="https://fonts.googleapis.com/css?family=Inconsolata" rel="stylesheet">

        <script src="js/three.js"></script>
        <script src="js/howler.core.js"></script>
        <script src="js/plugins/howler.spatial.js"></script>

        <script type="text/javascript" src="Checkpoints.json"></script>

        <div id="blocker">
            <div id="instructions">
                <span style="color: 0xffdddd">
                    <br />
                    Try to reach as many beacons as you can.<br/>Destroy the drones to regain ammunition for your secondary weapon.<br/>Use it to rocket jump!
                    <br/><br/>
                </span>
                (W, A, S, D = Move, SPACE = (double) Jump, MOUSE = Look around, LEFT CLICK = Shoot, RIGHT CLICK = Switch weapons)
                <br/><br/>
                <span style="font-size:40px">Loading...<span id="loadingProgress">0</span>%</span><br/>
                <span style="font-size:40px">Click to play</span><br/>
            </div>
        </div>

        <div id="info">
            <div style="float: right;">
                <span style="text-align: right;">beacons got: <span id="beaconsGot">0</span></span>
            </div>
            time left: <span id="timeLeft">00:00</span><span id="timeDeltas" style="color: #80ff80"></span><br/>
            <!--drones left: <span id="inhibitorsLeft" style="color: #ffff00"></span>-->
        </div>

        <script>
            Howler.volume(1.0);

            var pannerAttrs = {
                coneInnerAngle: 360,
                coneOuterAngle: 360,
                coneOuterGain: 0,
                distanceModel: 'inverse',
                maxDistance: 10000,
                panningModel: 'HRTF',
                refDistance: 5.0,
                rolloffFactor: 1,
            };

            explosionSound = new Howl({src:['Sounds/Explosion.ogg']});
            explosionSound.pannerAttr(pannerAttrs);

            enemyHitSound = new Howl({src:['Sounds/Hit.ogg']});
            enemyHitSound.pannerAttr(pannerAttrs);

            beaconSound = new Howl({src:['Sounds/Machinery.ogg'], loop: true, autoplay: true});
            beaconSound.pause();
            beaconSound.pannerAttr(pannerAttrs);

            beaconPortSound = new Howl({src:['Sounds/Beacon.ogg']});
            //beaconPortSound.pannerAttr(pannerAttrs);

            timeGainSound = new Howl({src:['Sounds/TimeGain.ogg'], volume: 0.1});

            shieldDownSound = new Howl({src:['Sounds/ShieldDown.ogg']});

            noAmmoSound = new Howl({src:['Sounds/NoAmmo.ogg']});

            var camera, scene, renderer;
            var geometry, boxMaterial, mesh;
            var controlsEnabled = false;
            var playerPitchObject, playerObject;
            var beaconIcon;

            var loadingDone = false;

            var nextClearTimeDelta = 0;

            var levelGeometry;

            var raycaster;

            var blocker = document.getElementById( 'blocker' );
            var instructions = document.getElementById( 'instructions' );

            // http://www.html5rocks.com/en/tutorials/pointerlock/intro/

            var havePointerLock = 'pointerLockElement' in document || 'mozPointerLockElement' in document || 'webkitPointerLockElement' in document;

            if ( havePointerLock ) {
                var element = document.body;

                var pointerlockchange = function ( event ) {
                    if ( document.pointerLockElement === element || document.mozPointerLockElement === element || document.webkitPointerLockElement === element ) {
                        controlsEnabled = true;

                        blocker.style.display = 'none';
                    } else {
                        controlsEnabled = false;

                        blocker.style.display = '-webkit-box';
                        blocker.style.display = '-moz-box';
                        blocker.style.display = 'box';

                        instructions.style.display = '';
                    }
                };

                var pointerlockerror = function ( event ) {
                    instructions.style.display = '';
                };

                // Hook pointer lock state change events
                document.addEventListener( 'pointerlockchange', pointerlockchange, false );
                document.addEventListener( 'mozpointerlockchange', pointerlockchange, false );
                document.addEventListener( 'webkitpointerlockchange', pointerlockchange, false );

                document.addEventListener( 'pointerlockerror', pointerlockerror, false );
                document.addEventListener( 'mozpointerlockerror', pointerlockerror, false );
                document.addEventListener( 'webkitpointerlockerror', pointerlockerror, false );

                instructions.addEventListener( 'click', function ( event ) {
                    if(loadingDone) {
                        instructions.style.display = 'none';

                        // Ask the browser to lock the pointer
                        element.requestPointerLock = element.requestPointerLock || element.mozRequestPointerLock || element.webkitRequestPointerLock;
                        element.requestPointerLock();
                    }
                }, false );

            } else {
                instructions.innerHTML = 'Your browser doesn\'t seem to support Pointer Lock API';
            }

            var moveForward = false;
            var moveBackward = false;
            var moveLeft = false;
            var moveRight = false;
            var canJump = false;
            var maxJumps = 2;

            var prevTime = null;

            var weaponLight, sceneLight;

            var leftMouseDown;

            var randoBox = new THREE.SphereGeometry(0.2, 12, 12);
            var randoBigSphere = new THREE.SphereGeometry(0.5, 12, 12);
            var randoMat = new THREE.MeshBasicMaterial({color: 0xffff00});
            var randoMatBlue = new THREE.MeshBasicMaterial({color: 0x00ff00});

            var maxBullets = 1024;
            var nextBulletIndex = 0;
            var bullets = new Array(maxBullets);

            var bulletGeometries = {};
            var bulletMaterials = {};
            var energyGunTextures = [];

            var bulletVelocities = {
                rifle: 100.0,
                energyGun: 30.0
            }

            var bulletFriction = {
                rifle: 0.0,
                energyGun: 0.0,
            }

            var nextShot = {
                rifle: 0,
                energyGun: 0
            };

            var bulletOffset = {
                //rifle: new THREE.Vector4(0.25, -0.13, -2.0, 0.0),
                rifle: new THREE.Vector4(0.0, 0.0, 0.0, 0.0),
                energyGun: new THREE.Vector4(0.0, -0.0, -0.0, 0.0),
            }

            var bulletMass = {
                rifle: 0.0,
                energyGun: 2.0
            }

            var bulletScales = {
                rifle: new THREE.Vector3(1, 1, 30),
                energyGun: new THREE.Vector3(10, 10, 10),
            }

            var shotInterval = {
                rifle: 100,
                energyGun: 1300, //700, // We know you can cheat this by spamming 1-2-1-2
            }

            var weaponDamage = {
                rifle: 15,
                energyGun: 200,
            }

            var weaponSounds = {
                rifle: new Howl({src: ['Sounds/Fire1.ogg'], volume: 0.3}),
                energyGun: new Howl({src: ['Sounds/Fire2.ogg'], volume: 0.3}),
            }

            var ammo = 2;
            var ammoIndicators = [];
            var ammoGainThing;
            var ammoGainThingEvolution = 100.0;

            var rifleMesh = new THREE.Object3D();
            var grenadeMesh = new THREE.Object3D();
            var currentWeapon = "rifle";

            var weaponKnockback = 0;


            function randomAngle() {
                return Math.random()*2.0*Math.PI;
            }

            function randomChoice(items) {
                return items[Math.floor(Math.random()*items.length)];
            }

            var nextSpawnEnemy = 0;
            var enemyTypes = ['cannonFodder'];
            var spawners = [];
            var spawnerRadius = 2.0;
            var spawnerGeometry = new THREE.SphereGeometry(spawnerRadius, 24, 24);
            var spawnerMaterial = new THREE.MeshBasicMaterial({color: 0x0000ff});

            var enemyGeometries = {
                cannonFodder: new THREE.BoxGeometry(1.0, 1.0, 1.0, 1, 1, 1),
            }

            var enemyMaterials = {
                cannonFodder: new THREE.MeshBasicMaterial({color: 0xff0000}),
            }

            var enemyFriction = {
                cannonFodder: 1.0
            }

            var enemyMaxHealth = {
                cannonFodder: 100
            };

            var enemyThink = {};

            enemyThink['cannonFodder'] = function(enemy) {
                enemy.moveDir = new THREE.Vector3(rand(-1, 1), 0.0, rand(-1, 1)).multiplyScalar(10);
                return enemy.state;
            }

            var enemies = [];

            var enemyExplosionMaterial;

            var beacon;
            var beaconMaterial;
            var beaconGeometry;
            var beaconPositions = [];
            var beaconState = 'vulnerable';
            var minBeaconScale;
            var maxBeaconScale;
            var beaconBarrier;
            var beaconEnemiesToKill = 2;

            var beaconTimeMatrix = [
                [20, 15, 15, 15, 15, 15, 15],
                [15,  0, 15, 15, 15, 15, 15],
                [15, 15,  0, 15, 15, 15, 15],
                [15, 15, 15,  0, 15, 15, 15],
                [15, 15, 15, 15,  0, 15, 15],
                [15, 15, 15, 15, 15,  0, 15],
                [15, 15, 15, 15, 15, 15,  0],
            ];

            var timeLeft = beaconTimeMatrix[0][0];

            var beaconsCollected = 0;
            var maxBeaconIndex = [0, 1, 2, 5, 8, 10, 12];
            var currentBeaconIndex = 0;
            var nextBeaconIndex = undefined;
            var beaconTimeFactor = 0.85;
            var beaconIconTexture;
            var beaconIconShieldTexture;

            function lineOfSight(from, to) {
                raycaster.ray.origin.copy(from);
                var rel = to.clone().sub(from);
                raycaster.ray.direction.copy(rel.clone().normalize());
                var intersections = raycaster.intersectObject(levelGeometry, true);
                if(intersections.length == 0 || intersections[0].distance > rel.length()) return true;
                return false;
            }

            function updateEnemies(dt) {
                if(nextSpawnEnemy < performance.now() && enemies.length < 15) {
                    nextSpawnEnemy = performance.now() + 200;
                    spawnSpawner(randomChoice(enemyTypes));
                }

                // update spawners
                for(var i = spawners.length - 1; i >= 0; --i) {
                    var spawner = spawners[i];

                    spawner.age += dt;
                    var scaleUpTime = 0.8;
                    var scaleDownTime = 0.3;
                    var scalePauseTime = 0.7;
                    var finalScale = 2.0;
                    if(spawner.age < scaleUpTime) {
                        var scale = spawner.mesh.scale.x + dt / scaleUpTime * finalScale;
                        spawner.mesh.scale.set(scale, scale, scale);
                    } else if(spawner.age > scaleUpTime && spawner.age < scaleUpTime + scalePauseTime) {
                        if(spawner.enemyType != undefined) {
                            spawnEnemy(spawner.enemyType, spawner.mesh.position);
                            spawner.enemyType = undefined;
                        }
                    } else if(spawner.age > scaleUpTime + scalePauseTime && spawner.age < scaleUpTime + scalePauseTime + scaleDownTime) {
                        var scale = spawner.mesh.scale.x - dt / scaleDownTime * finalScale;
                        spawner.mesh.scale.set(scale, scale, scale);
                    } else {
                        // destroy spawner
                        scene.remove(spawner.mesh);
                        spawners.splice(i, 1);
                    }
                }

                // update enemy
                var visible = 0;
                for(var i = enemies.length - 1; i >= 0; --i) {
                    var enemy = enemies[i];
                    var eType = enemy.enemyType;
                    enemy.mesh.material = enemyMaterials[eType];
                    enemy.age += dt;

                    if(enemy.nextThink < performance.now()) {
                        enemy.state = enemyThink[eType](enemy);
                        enemy.nextThink = performance.now() + 2000;
                    }

                    // act
                    enemy.mesh.actor.applyForce(enemy.moveDir, dt);
                    enemy.mesh.actor.updatePhysics(dt);

                    if(lineOfSight(playerObject.position, enemy.mesh.position)) {
                        visible += 1;
                        enemy.age = 0.0;
                    } else {
                        if(enemy.age > 10.0) {
                            scene.remove(enemy.mesh);
                            enemies.splice(i, 1);
                        }
                    }
                }
            }

            function spawnEnemy(enemyType, position) {
                var mesh = new THREE.Mesh(enemyGeometries[enemyType], enemyMaterials[enemyType]);
                mesh.position.copy(position);
                scene.add(mesh);

                var enemy = Object();
                enemy.mesh = mesh;
                enemy.enemyType = enemyType;
                enemy.state = 'idle';
                enemy.nextThink = performance.now() + 1000;
                enemy.health = enemyMaxHealth[enemyType];
                enemies.push(enemy);
                new PhysicsActor(enemy.mesh);
                enemy.mesh.actor.friction = 1.0;
                enemy.mesh.actor.height = 1.0;
                enemy.mesh.actor.edgeGuard = true;
                enemy.moveDir = new THREE.Vector3();
                enemy.age = 0.0;
                //console.log("spawn: ", enemyType);
            }

            function enemyExplosion(position) {
                var mesh = new THREE.Mesh(bulletGeometries['energyGun'], enemyExplosionMaterial.clone());
                mesh.position.copy(position);
                enemyExplosions.add(mesh);
            }

            function getEnemyHeights() {
                var heights = [];
                for(var i = 0; i < enemies.length; ++i) {
                    heights.push(enemies[i].mesh.position.y);
                }
                return heights;
            }

            function updateEnemyExplosions(dt) {
                var toDelete = [];
                enemyExplosions.traverse(function(explosion) {
                    if(explosion.material) {
                        var scale = explosion.scale.x;
                        var targetScale = 40.0;
                        scale = scale + (targetScale - scale) * 10.0 * dt;
                        explosion.scale.set(scale, scale, scale);
                        explosion.material.opacity -= 3.0 * dt;

                        if(explosion.material.opacity <= 0.0) {
                            toDelete.push(explosion);
                        }
                    }
                });

                for(var i = 0; i < toDelete.length; ++i) {
                    enemyExplosions.remove(toDelete[i]);
                }
            }

            function hitEnemy(enemy, damage) {
                enemy.health -= damage;
                enemy.mesh.material = enemyMaterials[enemy.enemyType + "_hit"];
                var _sound = enemyHitSound.play();
                enemyHitSound.rate(rand(0.95, 1.05), _sound);
                enemyHitSound.pos(enemy.mesh.position.x, enemy.mesh.position.y, enemy.mesh.position.z, _sound);
                if(enemy.health <= 0) {
                    var index = enemies.indexOf(enemy);
                    enemies.splice(index, 1);
                    enemyExplosion(enemy.mesh.position);
                    scene.remove(enemy.mesh);
                    beaconEnemiesToKill = Math.max(0, beaconEnemiesToKill - 1);
                    var delta = Math.max(1.0, Math.floor(100 * 3 * Math.pow(beaconTimeFactor, beaconsCollected)) / 100);
                    timeLeft += delta;
                    document.getElementById("timeDeltas").innerHTML = " +" + delta;
                    nextClearTimeDelta = performance.now() + 1000;
                    var _sound = timeGainSound.play();
                    //timeGainSound.rate(rand(0.95, 1.05), _sound);
                    ammoIndicators[ammo].material.color = new THREE.Vector3(0.1, 1.0, 0.1);
                    ammo = Math.min(5, ammo + 1);
                    ammoGainThingEvolution = 0.0;
                }
            }

            function spawnSpawner(enemyType, position = undefined) {
                if(position == undefined) {
                    switch(enemyType) {
                        case 'cannonFodder':
                            position = randomFloorPosition().add(new THREE.Vector3(0, spawnerRadius/2, 0));
                            break;
                    }
                }

                var spawner = Object();
                spawner.mesh = new THREE.Mesh(spawnerGeometry, spawnerMaterial);
                spawner.mesh.scale.set(0, 0, 0);
                spawner.mesh.position.copy(position);
                scene.add(spawner.mesh);

                spawner.age = 0.0;
                spawner.enemyType = enemyType;
                spawners.push(spawner);
            }

            function shoot(position, direction, type, creator) {
                weaponKnockback = 1.0;

                if(type == 'energyGun') {
                    if(ammo == 0) {
                        noAmmoSound.play();
                        return;
                    }
                    ammo -= 1;
                    ammoIndicators[ammo].material.color = new THREE.Vector3(0.3, 0.3, 0.3);
                }

                var bullet = new Object();
                bullet.semimass = bulletMass[type];
                bullet.alive = true;
                bullet.creator = creator;
                bullet.mesh = new THREE.Mesh(bulletGeometries[type], bulletMaterials[type]);
                //console.log("dir: ", direction);
                bullet.velocity = direction.clone().multiplyScalar(bulletVelocities[type]);
                bullet.mesh.position.copy(position);
                var offset = bulletOffset[type].clone();
                bullet.mesh.position.add(offset.applyMatrix4(camera.matrixWorld));
                //bullet.mesh.rotation.set(randomAngle(), randomAngle(), randomAngle());
                bullet.mesh.scale.copy(bulletScales[type]);
                bullet.mesh.lookAt(bullet.mesh.position.clone().add(bullet.velocity));
                bullet.lifetime = 10.0;
                bullet.bulletType = type;
                var _sound = weaponSounds[type].play();
                weaponSounds[type].rate(rand(0.9, 1.1), _sound);
                scene.add(bullet.mesh);

                bullets[nextBulletIndex] = bullet;
                nextBulletIndex += 1;
                if(nextBulletIndex >= maxBullets) nextBulletIndex = 0;
            }

            function extend(list, ext) {
                for(var i = 0; i < ext.length; ++i) {
                    list.push(ext[i]);
                }
            }

            function updateBullets(dt) {
                for(var i = 0; i < maxBullets; ++i) {
                    var bullet = bullets[i];
                    if(bullet == undefined) break;
                    if(bullet.alive) {
                        bullet.lifetime -= dt;
                        if(bullet.lifetime <= 0) {
                            bullet.alive = false;
                        } else {
                            bullet.velocity.add(new THREE.Vector3(0, -9.81, 0).multiplyScalar(bullet.semimass * dt));
                            bullet.velocity.sub(bullet.velocity.clone().multiplyScalar(bulletFriction[bullet.bulletType]*dt));

                            var oldPosition = bullet.mesh.position.clone();
                            var deltaPos = bullet.velocity.clone().multiplyScalar(dt);
                            bullet.mesh.position.add(deltaPos);
                            if(bullet.bulletType == "energyGun") {
                                //bullet.mesh.rotation.set(bullet.mesh.rotation.x + 5 * dt, bullet.mesh.rotation.y, bullet.mesh.rotation.z);
                                bullet.mesh.rotateOnAxis(new THREE.Vector3(1, 0, 0), 5*dt);
                            } else {
                                bullet.mesh.lookAt(bullet.mesh.position.clone().add(bullet.velocity));
                            }

                            raycaster.ray.origin.copy(oldPosition);
                            raycaster.ray.direction.copy(bullet.velocity.clone().normalize());
                            var intersections = raycaster.intersectObject(levelGeometry, true);
                            for(var j = 0; j < intersections.length; ++j) intersections[j].fromLevel = true;

                            for(var e = 0; e < enemies.length; ++e) {
                                var enemyIntersections = raycaster.intersectObject(enemies[e].mesh, false);
                                if(enemyIntersections.length > 0) {
                                    enemyIntersections[0].enemyHit = enemies[e];
                                    intersections.push(enemyIntersections[0]);
                                }
                            }
                            intersections.sort(function(a, b) {return a.distance - b.distance;});

                            if(intersections.length > 0) {
                                var diff = intersections[0].distance - deltaPos.length();
                                if(diff < 0.0) {
                                    bullet.alive = false;
                                    bullet.mesh.material = bullet.mesh.material.clone();
                                    bullet.mesh.position.sub(deltaPos.clone().normalize().multiplyScalar(-diff));

                                    if(bullet.bulletType == 'energyGun') {
                                        var _sound = explosionSound.play();
                                        explosionSound.rate(rand(0.9, 1.1), _sound);
                                        explosionSound.volume(1.0, _sound);
                                        explosionSound.pos(bullet.mesh.position.x, bullet.mesh.position.y, bullet.mesh.position.z, _sound);
                                        //console.log("b", bullet.mesh.position.x, bullet.mesh.position.y, bullet.mesh.position.z);
                                        //console.log("p", playerObject.position.x, playerObject.position.y, playerObject.position.z);
                                        //console.log("dist", bullet.mesh.position.clone().sub(playerObject.position).length());
                                    }

                                    /*var impactMesh = new THREE.Mesh(randoBox, randoMat);
                                    impactMesh.position.copy(bullet.mesh.position);
                                    scene.add(impactMesh);*/

                                    var maxBlast = 50.0;
                                    var blastRadius = 8.0;
                                    var blastYRescale = 0.5;

                                    for(var e = 0; e < enemies.length; ++e) {
                                        var enemy = enemies[e];
                                        var rel = enemy.mesh.position.clone().sub(bullet.mesh.position);

                                        if(bullet.bulletType == 'energyGun') {
                                            if(rel.length() < blastRadius) {
                                                var blastStrength;
                                                if(intersections[0].enemyHit == enemy) {
                                                    hitEnemy(enemy, weaponDamage['energyGun']);
                                                    blastStrength = maxBlast;
                                                } else {
                                                    blastStrength = rel.length() / blastRadius;
                                                    hitEnemy(enemy, weaponDamage['energyGun'] * blastStrength);
                                                    //blastStrength = Math.cos(blastStrength*Math.PI/2)*2.0-1.0;
                                                    blastStrength = 1.0 - blastStrength;
                                                    blastStrength *= maxBlast * 0.7;
                                                }
                                                enemy.mesh.actor.velocity.add(rel.clone().normalize().multiply(new THREE.Vector3(1.0, blastYRescale, 1.0)).multiplyScalar(blastStrength));
                                            }
                                        } else if(bullet.bulletType == 'rifle') {
                                            if(intersections[0].enemyHit == enemy) {
                                                hitEnemy(enemy, weaponDamage['rifle']);
                                                enemy.mesh.actor.velocity.add(rel.clone().normalize().multiplyScalar(1));
                                            }
                                        }
                                    }

                                    var rel = playerObject.position.clone().sub(bullet.mesh.position);
                                    if(bullet.bulletType == 'energyGun') {
                                        if(rel.length() < blastRadius) {
                                            blastStrength = (1.0 - rel.length() / blastRadius) * maxBlast * 1.0;
                                            playerObject.actor.velocity.add(rel.clone().normalize().multiply(new THREE.Vector3(1.0, blastYRescale, 1.0)).multiplyScalar(blastStrength));
                                        }
                                    } else {
                                        var blastRadius = 3.0;
                                        if(rel.length() < blastRadius) {
                                            var blastStrength = (1.0 - rel.length() / blastRadius) * -20;
                                            playerObject.actor.velocity.add(rel.clone().normalize().multiply(new THREE.Vector3(1.0, 0.6, 1.0)).multiplyScalar(blastStrength));
                                        }
                                    }
                                }
                            }
                        }
                    } else {
                        if(bullet.mesh.material.opacity > 0.0 && bullet.lifetime > 0.0) {
                            var targetScale = 50.0;
                            if(bullet.bulletType == "rifle") targetScale = 20.0;
                            var scale = bullet.mesh.scale.x;
                            var scale = scale + (targetScale - scale) * 10.0 * dt;
                            bullet.mesh.scale.set(scale, scale, scale);
                            bullet.mesh.material.opacity -= 3.0 * dt;
                        } else {
                            scene.remove(bullet.mesh);
                        }
                    }
                }
            }

            function rand(min, max) {
                return min + Math.random() * (max - min);
            }

            function randomLevelPosition() {
                //return new THREE.Vector3(0, 3, -5);
                var bbox = new THREE.Box3().setFromObject(levelGeometry);
                var rescale = 0.95;
                return new THREE.Vector3(rand(bbox.min.x*rescale, bbox.max.x*rescale),
                                         rand(bbox.min.y*rescale, bbox.max.y*rescale),
                                         rand(bbox.min.z*rescale, bbox.max.z*rescale));
            }

            function randomFloorPosition() {
                var found = false;
                while(!found) {
                    var pos = randomLevelPosition();
                    raycaster.ray.origin.copy(pos);
                    raycaster.ray.direction.set(0, -1, 0);
                    var intersections = raycaster.intersectObject(levelGeometry, true);
                    if(intersections.length > 0) {
                        pos.y -= intersections[0].distance;
                        found = true;
                        return pos;
                    }
                }
            }

            function PhysicsActor(obj3d) {
                this.obj = obj3d;
                obj3d.actor = this;
                this.velocity = new THREE.Vector3(0, 0, 0);

                // default values for player
                this.edgeGuard = false;
                this.height = 2.0;
                this.radius = 0.5;
                this.floorRayRadiusFactor = 0.8;
                this.rayFloorCount = 4;
                this.raySideCount = 8;
                this.friction = 10.0;
                this.jumpsLeft = 0;
            }

            var printIt = true;

            PhysicsActor.prototype.updatePhysics = function(dt, print=false) {
                // gravity
                this.velocity.y -= 9.8 * 2.0 * dt;

                // friction
                if(print) console.log("pre friction", this.velocity);
                this.velocity.x -= this.velocity.x * this.friction * dt;
                this.velocity.z -= this.velocity.z * this.friction * dt;
                if(print) console.log("pre integrage", this.velocity);

                this.obj.position.add(this.velocity.clone().multiplyScalar(dt));
                if(print) console.log("pos", this.obj.position);

                // floor rays
                var intersections = [];
                raycaster.ray.direction.set(0, -1, 0);

                for(var rayIndex = 0; rayIndex < this.rayFloorCount; ++rayIndex) {
                    var angle = 2.0 * Math.PI / this.rayFloorCount * rayIndex;
                    var x = Math.cos(angle) * this.radius * this.floorRayRadiusFactor + this.obj.position.x;
                    var z = Math.sin(angle) * this.radius * this.floorRayRadiusFactor + this.obj.position.z;

                    raycaster.ray.origin.set(x, this.obj.position.y, z);

                    if(print) console.log("raycast: ", raycaster.ray.origin, raycaster.ray.direction);
                    var rayIntersections = raycaster.intersectObject(levelGeometry, true);
                    if(print) console.log("closest per ray:", rayIntersections[0].distance, rayIntersections[0].face.normal);
                    if(rayIntersections.length > 0) {
                        rayIntersections[0].dirX = Math.cos(angle);
                        rayIntersections[0].dirZ = Math.sin(angle);
                        intersections.push(rayIntersections[0]); // remember closest
                    }
                }
                intersections.sort(function(a, b) {return a.distance - b.distance;});

                var isOnObject = false;
                // sorted by distance, closest first
                for(var i = 0; i < intersections.length; ++i) {
                    //console.log("intersection: ", intersections[i].distance);
                    var diff = intersections[i].distance - this.height;
                    if(diff < 0) {
                        if(print) console.log("diff:", diff);
                        this.obj.position.y -= diff;
                        if(print) console.log("pos:", this.obj.position.y);
                        var normal = intersections[i].face.normal;
                        if(print) {
                            console.log("normal: ", normal);
                            console.log("pre", this.velocity);
                        }
                        this.velocity.sub(normal.multiplyScalar(this.velocity.dot(normal) / normal.dot(normal)));
                        if(print) {
                            console.log("post", this.velocity);
                        }
                        isOnObject = true;
                        break;
                    }
                }

                if(this.edgeGuard) {
                    var edgeNormal = new THREE.Vector3();
                    var onEdge = false;
                    for(var i = 0; i < intersections.length; ++i) {
                        if(intersections[i].distance > this.height * 1.5) {
                            edgeNormal.add(new THREE.Vector3(intersections[i].dirX, 0, intersections[i].dirZ));
                            onEdge = true;
                        }
                    }
                    if(onEdge) {
                        edgeNormal.normalize();
                        this.obj.position.sub(edgeNormal.clone().multiplyScalar(this.radius*0.05));
                        this.velocity.sub(edgeNormal.multiplyScalar(this.velocity.dot(edgeNormal)));
                    }
                }

                var intersectionData, closestRay = undefined, undefined;
                raycaster.ray.origin.copy(this.obj.position)
                raycaster.ray.origin.y -= this.height * 0.7;

                for(var rayIndex = 0; rayIndex < this.raySideCount; ++rayIndex) {
                    var angle = 2.0 * Math.PI / this.raySideCount * rayIndex;
                    var x = Math.cos(angle);
                    var z = Math.sin(angle);
                    raycaster.ray.direction.set(x, 0, z);

                    var rayIntersections = raycaster.intersectObject(levelGeometry, true);
                    if(rayIntersections.length > 0 && (intersectionData == undefined || rayIntersections[0].distance < intersectionData.distance)) {
                        intersectionData = rayIntersections[0];
                        closestRay = new THREE.Vector3(x, 0, z);
                    }
                }

                if(closestRay != undefined) {
                    var diff = intersectionData.distance - this.radius;
                    if(diff < 0.0) {
                        var normal = intersectionData.face.normal;
                        //console.log("norm: ", normal, " - len: ", normal.length());
                        //console.log("vel pre: ", this.velocity);
                        //console.log()
                        this.obj.position.add(closestRay.multiplyScalar(diff*1.01));
                        this.velocity.sub(normal.multiplyScalar(this.velocity.dot(normal) / normal.dot(normal)));
                        //console.log("vel post: ", this.velocity);
                    }
                }

                if (isOnObject === true && this.velocity.y <= 0.0) {
                    this.jumpsLeft = 2;
                }
            }

            PhysicsActor.prototype.applyForce = function(force, dt) {
                this.velocity.add(force.clone().multiplyScalar(dt));
            }

            // init, animate

            init();
            animate();

            function init() {
                var width = window.innerWidth;
                var height = window.innerHeight;
                aspect = width / height;
                camera = new THREE.PerspectiveCamera( 80, aspect, 0.1, 150 );
                renderCamera = camera.clone();
                weaponCamera = new THREE.PerspectiveCamera( 90 / aspect, aspect, 0.01, 5 );
                hudCamera = new THREE.OrthographicCamera(-width/2, width/2, height/2, -height/2, 1, 10);
                hudCamera.position.set(0, 0, 5);

                scene = new THREE.Scene();
                unlitScene = new THREE.Scene();
                weaponScene = new THREE.Scene();
                hudScene = new THREE.Scene();

                enemyExplosions = new THREE.Object3D();
                unlitScene.add(enemyExplosions);

                //controls = new THREE.PointerLockControls( camera );

                playerPitchObject = new THREE.Object3D();
                playerPitchObject.add(camera);
                playerObject = new THREE.Object3D();
                playerObject.position.set(0, 1, 0);
                //playerObject.position.set(11, 60, -60);
                playerObject.add(playerPitchObject);
                new PhysicsActor(playerObject);
                playerObject.actor.rayFloorCount = 8;
                playerObject.actor.raySideCount = 12;
                scene.add(playerObject);

                var onMouseMove = function(event) {
                    //console.log(controlsEnabled);
                    if (controlsEnabled === false) return;

                    var movementX = event.movementX || event.mozMovementX || event.webkitMovementX || 0;
                    var movementY = event.movementY || event.mozMovementY || event.webkitMovementY || 0;

                    var sens = 0.001;
                    playerObject.rotation.y -= movementX * sens; // yaw
                    playerPitchObject.rotation.x -= movementY * sens;

                    playerPitchObject.rotation.x = Math.max(-Math.PI/2.0, Math.min(Math.PI/2.0, playerPitchObject.rotation.x));
                }
                document.addEventListener('mousemove', onMouseMove, false);

                var spaceWasDown = true;
                var onKeyDown = function ( event ) {
                    switch ( event.keyCode ) {
                        case 38: // up
                        case 87: // w
                            moveForward = true;
                            break;

                        case 37: // left
                        case 65: // a
                            moveLeft = true; break;

                        case 40: // down
                        case 83: // s
                            moveBackward = true;
                            break;

                        case 39: // right
                        case 68: // d
                            moveRight = true;
                            break;

                        case 32: // space
                            if (playerObject.actor.jumpsLeft > 0 && spaceWasDown) {
                                //console.log("jump!");
                                playerObject.actor.velocity.y = 8;
                                playerObject.position.y += 0.01;
                                playerObject.actor.jumpsLeft -= 1;
                                spaceWasDown = false;
                            }
                            break;
                        case 32: // 1
                            break;

                        case 50: // 2
                            break;

                        /*case 76: // l
                            mesh = new THREE.Mesh(randoBigSphere, randoMatBlue);
                            mesh.position.copy(randomFloorPosition());
                            scene.add(mesh);
                            break;*/
                    }
                    //console.log("key: ", event.keyCode);
                };

                var onKeyUp = function ( event ) {
                    switch( event.keyCode ) {
                        case 38: // up
                        case 87: // w
                            moveForward = false;
                            break;

                        case 37: // left
                        case 65: // a
                            moveLeft = false;
                            break;

                        case 40: // down
                        case 83: // s
                            moveBackward = false;
                            break;

                        case 39: // right
                        case 68: // d
                            moveRight = false;
                            break;
                        case 32:
                            spaceWasDown = true;
                            break;
                    }
                };

                var onMouseDown = function(event) {
                    if(event.button == 0) leftMouseDown = true;

                    if(event.button == 2) { // Switch weapons
                        if(currentWeapon == "rifle") {
                            rifleMesh.visible = false;
                            grenadeMesh.visible = true;
                            currentWeapon = "energyGun";
                        } else {
                            rifleMesh.visible = true;
                            grenadeMesh.visible = false;
                            currentWeapon = "rifle";
                        }
                    }
                }

                var onMouseUp = function(event) {
                    if(event.button == 0) leftMouseDown = false;
                }

                document.addEventListener('keydown', onKeyDown, false);
                document.addEventListener('keyup', onKeyUp, false);
                document.addEventListener('mousedown', onMouseDown, false);
                document.addEventListener('mouseup', onMouseUp, false);

                raycaster = new THREE.Raycaster();

                var manager = new THREE.LoadingManager();
                manager.onProgress = function ( item, loaded, total ) {
                    if(loaded == total) loadingDone = true;
                    document.getElementById("loadingProgress").innerHTML = Math.floor(loaded/total*100);
                };
                var jsonLoader = new THREE.JSONLoader(manager);
                var texLoader = new THREE.TextureLoader(manager);

                levelGeometry = new THREE.Object3D();
                unlitScene.add(levelGeometry);

                // weapons
                // rifle
                texLoader.load("Waffe1.png", function(texture) {
                    var material = new THREE.MeshPhongMaterial({map: texture});

                    // JSON is the only format, that's imported properly!
                    jsonLoader.load( 'Waffe1.json', function (geometry) {
                        rifleMesh = new THREE.Mesh(geometry, material);
                        rifleMesh.visible = true;
                        weaponScene.add(rifleMesh);
                    }/*, onProgress/*, onError*/);
                });

                var indicatorGeometry = new THREE.BoxGeometry(0.017, 0.01, 0.017, 1, 1, 1);
                var indicatorMaterial = new THREE.MeshPhongMaterial({color: 0x4c4c4c});

                // energy ball thing
                texLoader.load("Waffe2.png", function(texture) {
                    var material = new THREE.MeshPhongMaterial({map: texture});

                    jsonLoader.load( 'Waffe2.json', function (geometry) {
                        grenadeMesh = new THREE.Mesh(geometry, material);
                        grenadeMesh.visible = false;
                        weaponScene.add(grenadeMesh);

                        var pos = new THREE.Vector3(0.214, -0.103, -0.46);
                        for(var i = 0; i < 5; ++i) {
                            ammoIndicators.push(new THREE.Mesh(indicatorGeometry, indicatorMaterial.clone()));
                            if(i < ammo) ammoIndicators[i].material.color = new THREE.Vector3(0.1, 1.0, 0.1);
                            ammoIndicators[i].position.copy(pos).add(new THREE.Vector3(0, 0, 0.021 * i));
                            grenadeMesh.add(ammoIndicators[i]);
                        }
                    }/*, onProgress/*, onError*/);
                });

                // bullets
                jsonLoader.load("Plasma.json", function(geometry) {bulletGeometries["rifle"] = geometry;})
                jsonLoader.load("FireGreen.json", function(geometry) {bulletGeometries["energyGun"] = geometry;})

                texLoader.load("Shot.png", function(texture) {
                    bulletMaterials["rifle"] = new THREE.MeshBasicMaterial({
                        map: texture,
                        blending: THREE.AdditiveBlending,
                        side: THREE.DoubleSide,
                        transparent: true, // invisibility
                    });
                });

                texLoader.load("FireGreenA.png", function(texture) {
                    texture.wrapS = texture.wrapT = THREE.RepeatWrapping;
                    bulletMaterials["energyGun"] = new THREE.MeshBasicMaterial({
                        map: texture,
                        blending: THREE.AdditiveBlending,
                        //side: THREE.DoubleSide,
                        transparent: true, // invisibility
                        alphaTest: 0.1,
                    });
                })
                //texLoader.load("Plasma/Plasma1A.png", function(texture) {energyGunTextures.push(texture);});
                //texLoader.load("Plasma/Plasma2A.png", function(texture) {energyGunTextures.push(texture);});
                //texLoader.load("Plasma/Plasma3A.png", function(texture) {energyGunTextures.push(texture);});

                // other textures
                texLoader.load("Normal.png", function(normalTexture){
                    texLoader.load("EnvironmentMap.jpg", function(envTexture) {
                        envTexture.mapping = THREE.EquirectangularRefractionMapping;
                        spawnerMaterial = new THREE.MeshStandardMaterial({
                            color: 0xaaaaff, emissive: 0x303070, envMap: envTexture,
                            normalMap: normalTexture, normalScale: new THREE.Vector2(4.0, 4.0)});

                        texLoader.load("Drone.png", function(texture) {
                            enemyMaterials['cannonFodder'] = new THREE.MeshStandardMaterial({map: texture});
                            enemyMaterials['cannonFodder_hit'] = new THREE.MeshStandardMaterial({map: texture, emissive: 0xff0000});
                        })
                    })
                })

                texLoader.load("Fire.jpg", function(texture) {
                    enemyExplosionMaterial = new THREE.MeshBasicMaterial({
                        map: texture,
                        transparent: true,
                        blending: THREE.AdditiveBlending,
                        alphaTest: 0.1,
                    })
                })

                // HUD
                texLoader.load("Crosshair.png", function(texture) {
                    var width = 32;
                    var height = 32;
                    var mesh = new THREE.Mesh(new THREE.PlaneGeometry(width, height), new THREE.MeshBasicMaterial({map: texture, transparent: true}));
                    hudScene.add(mesh);
                })


                texLoader.load("BeaconIconSmall.png", function(texture) {
                    beaconIconShieldTexture = texture;
                    var width = 64;
                    var height = 64;
                    beaconIcon = new THREE.Mesh(new THREE.PlaneGeometry(width, height), new THREE.MeshBasicMaterial({map: texture, transparent: true}));
                    hudScene.add(beaconIcon);
                })

                /*texLoader.load("BeaconIconSmall.png", function(texture) {
                    beaconIconTexture = texture;
                })*/

                ammoGainThing = new THREE.Mesh(new THREE.SphereGeometry(0.2, 32, 32), new THREE.MeshPhongMaterial({color: 0x60ff60, transparent: true, opacity: 0.5}));
                ammoGainThing.position.set(0.27, -0.104, -0.444);
                ammoGainThing.scale.set(0.1, 0.1, 0.1);
                weaponScene.add(ammoGainThing);

                // enemies
                jsonLoader.load("Drone.json", function(geometry) {
                    enemyGeometries['cannonFodder'] = geometry;
                })

                // floor
                texLoader.load("DetailMap.jpg", function(texture) {
                    texture.wrapS = texture.wrapT = THREE.RepeatWrapping;
                    texLoader.load("Lightmap.png", function(lightMap) {
                        var floorMaterial = new THREE.MeshPhongMaterial({map: texture, lightMap: lightMap, lightMapIntensity: 1.0});

                        // JSON is the only format, that's imported properly!
                        jsonLoader.load( 'Level.json', function (geometry) {
                            var floorMesh = new THREE.Mesh(geometry, floorMaterial);
                            floorMesh.position.y = 0;
                            levelGeometry.add(floorMesh);
                        }/*, onProgress/*, onError*/);
                    });
                });

                var cps = checkpoints.object.children;
                for(var i = 0; i < cps.length; ++i) {
                    beaconPositions.push(new THREE.Vector3(-cps[i].matrix[12], cps[i].matrix[13], -cps[i].matrix[14]));
                }

                texLoader.load("Gate.png", function(texture) {
                    beaconMaterial = new THREE.MeshStandardMaterial({map: texture});

                    jsonLoader.load("Gate.json", function(geometry) {
                        beaconGeometry = geometry;
                        beacon = new THREE.Mesh(geometry, beaconMaterial);
                        beacon.position.copy(beaconPositions[0]);
                        scene.add(beacon);
                        beaconBarrier = new THREE.Mesh(new THREE.SphereGeometry(1.0, 32, 32), new THREE.MeshBasicMaterial({color: 0xaaaaff, transparent: true, opacity: 0.2, depthWrite: false}));
                        beacon.add(beaconBarrier);
                    })
                })

                sceneLight = new THREE.DirectionalLight( 0xffffbb, 1 );
                sceneLight.position.set(-1, -1, -1);
                scene.add(sceneLight);

                weaponLight = new THREE.DirectionalLight( 0xffffbb, 0.4 );
                weaponScene.add(weaponLight);

                ambientLightS = new THREE.AmbientLight(0x808080);
                scene.add(ambientLightS);

                ambientLightW = new THREE.AmbientLight(0x909090);
                weaponScene.add(ambientLightW);

                renderer = new THREE.WebGLRenderer();
                renderer.setClearColor( 0xffffff );
                renderer.setPixelRatio( window.devicePixelRatio );
                renderer.setSize( window.innerWidth, window.innerHeight );
                renderer.autoClear = false;
                document.body.appendChild( renderer.domElement );

                window.addEventListener( 'resize', onWindowResize, false );
            }

            function onWindowResize() {
                camera.aspect = window.innerWidth / window.innerHeight;
                weaponCamera.aspect = camera.aspect;
                camera.updateProjectionMatrix();
                weaponCamera.updateProjectionMatrix();

                renderer.setSize( window.innerWidth, window.innerHeight );
            }

            function animate() {
                requestAnimationFrame( animate );

                if (controlsEnabled) {
                    // time
                    var time = performance.now();
                    if(prevTime == null) prevTime = performance.now();
                    var dt_ms = time - prevTime; //Math.min(time - prevTime, 10);
                    var dt = dt_ms / 1000;
                    prevTime = time;

                    // movement
                    var accell = 120.0;
                    var moveAccell = new THREE.Vector4(0, 0, 0, 0);
                    if(moveForward) moveAccell.z = -accell;
                    if(moveBackward) moveAccell.z = accell;

                    if(moveLeft) moveAccell.x = -accell;
                    if(moveRight) moveAccell.x = accell;
                    playerObject.localToWorld(moveAccell);
                    playerObject.actor.velocity.add(moveAccell.normalize().multiplyScalar(dt * accell));

                    // shooting
                    if(leftMouseDown && nextShot[currentWeapon] < time) {
                        nextShot[currentWeapon] = time + shotInterval[currentWeapon];
                        var dir = new THREE.Vector4(0, 0, -1, 0).applyMatrix4(camera.matrixWorld);
                        shoot(playerObject.position, new THREE.Vector3(dir.x, dir.y, dir.z), currentWeapon, undefined);
                    }

                    weaponScene.position.z = weaponKnockback * 0.05;
                    weaponKnockback -= Math.max(weaponKnockback * 5.0 * dt, 1.0 * dt);
                    weaponKnockback = Math.max(0, weaponKnockback);

                    ammoGainThingEvolution += dt;
                    var scale = 0.1;
                    var duration = 0.5;
                    if(ammoGainThingEvolution < duration) {
                        scale = Math.sin(ammoGainThingEvolution/duration*Math.PI);
                    }
                    ammoGainThing.scale.set(scale, scale, scale);

                    playerObject.actor.updatePhysics(dt);
                    updateEnemies(dt)

                    updateBullets(dt);
                    updateEnemyExplosions(dt);
                    //bulletMaterials["energyGun"].map = randomChoice(energyGunTextures);

                    // beacon
                    var playerBeaconRel = beacon.position.clone().sub(playerObject.position);
                    var beaconRotationSpeed = 2.0;
                    switch(beaconState) {
                        case 'hardened':
                            beaconBarrier.visible = true;
                            if(beaconEnemiesToKill <= 0) {
                                beaconState = 'vulnerable';
                                shieldDownSound.play();
                                beaconIcon.material.map = beaconIconTexture;
                            }
                            break;
                        case 'vulnerable':
                            minBeaconScale = 2.0;
                            maxBeaconScale = 2.5;
                            beaconBarrier.visible = false;
                            if(playerBeaconRel.length() < 5.0) {
                                beaconState = 'relocating';
                                beaconPortSound.play();

                                beaconsCollected += 1;
                                var maxIndex = currentBeaconIndex;
                                for(var i = 0; i < maxBeaconIndex.length; ++i) {
                                    if(maxBeaconIndex[i] > beaconsCollected) break;
                                    maxIndex = i;
                                }
                                nextBeaconIndex = currentBeaconIndex;
                                while(nextBeaconIndex == currentBeaconIndex)
                                    nextBeaconIndex = Math.floor(Math.random()*(maxIndex+1));
                                timeLeft += beaconTimeMatrix[currentBeaconIndex][nextBeaconIndex] * Math.pow(beaconTimeFactor, beaconsCollected);
                                document.getElementById("timeDeltas").innerHTML = " +" + delta;
                                nextClearTimeDelta = performance.now() + 1000;
                            }
                            break;
                        case 'relocating':
                            beaconRotationSpeed = 10.0;
                            minBeaconScale = Math.max(minBeaconScale - 1.5 * dt, 0.0);
                            maxBeaconScale = Math.min(maxBeaconScale + 1.0 * dt, 3.0);
                            break;
                    }
                    beacon.rotation.y += beaconRotationSpeed * dt;
                    var scale = (Math.cos(performance.now() / 1000 * 3.0)*0.5+0.5) * (maxBeaconScale - minBeaconScale) + minBeaconScale;
                    beacon.scale.set(scale, scale, scale);
                    if(!beaconSound.playing()) beaconSound.play();
                    beaconSound.pos(beacon.position.x, beacon.position.y, beacon.position.z);

                    if(beaconState == 'relocating' && Math.abs(scale) < 0.1) {
                        beaconPortSound.play();
                        //beaconIcon.material.map = beaconIconShieldTexture;

                        beacon.position.copy(beaconPositions[nextBeaconIndex]);
                        beaconState = 'vulnerable';
                        beaconEnemiesToKill = 3;
                        currentBeaconIndex = nextBeaconIndex;
                        nextBeaconIndex = undefined;
                    }

                    // HUD
                    var beaconPos = beacon.position.clone();
                    beaconPosNDC = beaconPos.clone().project(camera);
                    var ndcClamp = 0.9;
                    beaconPosNDC.x = Math.max(Math.min(beaconPosNDC.x, ndcClamp), -ndcClamp);
                    beaconPosNDC.y = Math.max(Math.min(beaconPosNDC.y, ndcClamp), -ndcClamp);

                    var proj = new THREE.Matrix4();
                    proj.getInverse(camera.matrixWorld);
                    if(beaconPos.applyMatrix4(proj).z > 0) {
                        beaconPosNDC.x = beaconPosNDC.x > 0.0 ? -ndcClamp : ndcClamp;
                        beaconPosNDC.y = beaconPosNDC.y > 0.0 ? -ndcClamp : ndcClamp;
                    }

                    beaconPosNDC.multiply(new THREE.Vector3(window.innerWidth/2, window.innerHeight/2, 0.0));
                    beaconIcon.position.copy(beaconPosNDC);

                    timeLeft -= dt;
                    var minutes = Math.floor(timeLeft / 60);
                    var seconds = Math.floor(timeLeft - minutes*60);
                    if(minutes < 10) minutes = "0" + minutes;
                    if(seconds < 10) seconds = "0" + seconds;
                    document.getElementById("timeLeft").innerHTML = minutes + ":" + seconds;
                    if(timeLeft < 10.0) {
                        document.getElementById("timeLeft").style.color = "#ff4040";
                    } else {
                        document.getElementById("timeLeft").style.color = "#40ff40";
                    }
                    if(nextClearTimeDelta < time) {
                        document.getElementById("timeDeltas").innerHTML = "";
                    }

                    /*document.getElementById("inhibitorsLeft").innerHTML = beaconEnemiesToKill;
                    if(beaconEnemiesToKill > 0) {
                        document.getElementById("inhibitorsLeft").style.color = "#ffff40";
                    } else {
                        document.getElementById("inhibitorsLeft").style.color = "#40ff40";
                    }*/

                    document.getElementById("beaconsGot").innerHTML = beaconsCollected;
                } else {
                    if(beaconSound.playing()) beaconSound.pause();
                    prevTime = performance.now();
                }

                renderer.clear();
                // FUCK THREE.JS I WILL NEVER USE IT AGAIN. WHAT EVEN IS THIS?
                renderCamera.matrixWorld = camera.matrixWorld.clone();
                renderCamera.matrixAutoUpdate = false;
                renderer.render(unlitScene, renderCamera);
                renderer.render(scene, renderCamera);

                renderer.clearDepth();
                var lightDir = new THREE.Vector4();
                lightDir.set(sceneLight.position.x, sceneLight.position.y, sceneLight.position.z, 0.0);
                playerObject.worldToLocal(lightDir);
                //lightDir.applyMatrix4(mat.getInverse());
                weaponLight.position.set(lightDir.x, -lightDir.y, lightDir.z);
                renderer.render(weaponScene, weaponCamera);

                Howler.pos(playerObject.position.x, playerObject.position.y, playerObject.position.z);
                var dir = playerPitchObject.getWorldDirection();
                var right = dir.clone().cross(new THREE.Vector3(0, 1, 0));
                var up = dir.clone().cross(right);
                Howler.orientation(dir.x, dir.y, dir.z, up.x, up.y, up.z);

                renderer.clearDepth();
                renderer.render(hudScene, hudCamera);
            }

        </script>
    </body>
</html>